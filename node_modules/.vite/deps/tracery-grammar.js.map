{
  "version": 3,
  "sources": ["../../tracery-grammar/tracery.js"],
  "sourcesContent": ["/**\n * @author Kate\n */\n\nvar tracery = function() {\n    var rng = Math.random;\n\n    var setRng = function setRng(newRng) {\n        rng = newRng;\n    }\n\n    var TraceryNode = function(parent, childIndex, settings) {\n        this.errors = [];\n\n        // No input? Add an error, but continue anyways\n        if (settings.raw === undefined) {\n            this.errors.push(\"Empty input for node\");\n            settings.raw = \"\";\n        }\n\n        // If the root node of an expansion, it will have the grammar passed as the 'parent'\n        //  set the grammar from the 'parent', and set all other values for a root node\n        if ( parent instanceof tracery.Grammar) {\n            this.grammar = parent;\n            this.parent = null;\n            this.depth = 0;\n            this.childIndex = 0;\n        } else {\n            this.grammar = parent.grammar;\n            this.parent = parent;\n            this.depth = parent.depth + 1;\n            this.childIndex = childIndex;\n        }\n\n        this.raw = settings.raw;\n        this.type = settings.type;\n        this.isExpanded = false;\n\n        if (!this.grammar) {\n            this.errors.push(\"No grammar specified for this node \" + this);\n        }\n\n    };\n\n    TraceryNode.prototype.toString = function() {\n        return \"Node('\" + this.raw + \"' \" + this.type + \" d:\" + this.depth + \")\";\n    };\n\n    // Expand the node (with the given child rule)\n    //  Make children if the node has any\n    TraceryNode.prototype.expandChildren = function(childRule, preventRecursion) {\n        this.children = [];\n        this.finishedText = \"\";\n\n        // Set the rule for making children,\n        // and expand it into section\n        this.childRule = childRule;\n        if (this.childRule !== undefined) {\n            var sections = tracery.parse(childRule);\n\n            // Add errors to this\n            if (sections.errors.length > 0) {\n                this.errors = this.errors.concat(sections.errors);\n\n            }\n\n            for (var i = 0; i < sections.length; i++) {\n                this.children[i] = new TraceryNode(this, i, sections[i]);\n                if (!preventRecursion)\n                    this.children[i].expand(preventRecursion);\n\n                // Add in the finished text\n                this.finishedText += this.children[i].finishedText;\n            }\n        } else {\n            // In normal operation, this shouldn't ever happen\n            this.errors.push(\"No child rule provided, can't expand children\");\n        }\n    };\n\n    // Expand this rule (possibly creating children)\n    TraceryNode.prototype.expand = function(preventRecursion) {\n\n        if (!this.isExpanded) {\n            this.isExpanded = true;\n\n            this.expansionErrors = [];\n\n            // Types of nodes\n            // -1: raw, needs parsing\n            //  0: Plaintext\n            //  1: Tag (\"#symbol.mod.mod2.mod3#\" or \"#[pushTarget:pushRule]symbol.mod\")\n            //  2: Action (\"[pushTarget:pushRule], [pushTarget:POP]\", more in the future)\n\n            switch(this.type) {\n            // Raw rule\n            case -1:\n\n                this.expandChildren(this.raw, preventRecursion);\n                break;\n\n            // plaintext, do nothing but copy text into finsihed text\n            case 0:\n                this.finishedText = this.raw;\n                break;\n\n            // Tag\n            case 1:\n                // Parse to find any actions, and figure out what the symbol is\n                this.preactions = [];\n                this.postactions = [];\n\n                var parsed = tracery.parseTag(this.raw);\n\n                // Break into symbol actions and modifiers\n                this.symbol = parsed.symbol;\n                this.modifiers = parsed.modifiers;\n\n                // Create all the preactions from the raw syntax\n                for (var i = 0; i < parsed.preactions.length; i++) {\n                    this.preactions[i] = new NodeAction(this, parsed.preactions[i].raw);\n                }\n                for (var i = 0; i < parsed.postactions.length; i++) {\n                    //   this.postactions[i] = new NodeAction(this, parsed.postactions[i].raw);\n                }\n\n                // Make undo actions for all preactions (pops for each push)\n                for (var i = 0; i < this.preactions.length; i++) {\n                    if (this.preactions[i].type === 0)\n                        this.postactions.push(this.preactions[i].createUndo());\n                }\n\n                // Activate all the preactions\n                for (var i = 0; i < this.preactions.length; i++) {\n                    this.preactions[i].activate();\n                }\n\n                this.finishedText = this.raw;\n\n                // Expand (passing the node, this allows tracking of recursion depth)\n\n                var selectedRule = this.grammar.selectRule(this.symbol, this, this.errors);\n\n                this.expandChildren(selectedRule, preventRecursion);\n\n                // Apply modifiers\n                // TODO: Update parse function to not trigger on hashtags within parenthesis within tags,\n                //   so that modifier parameters can contain tags \"#story.replace(#protagonist#, #newCharacter#)#\"\n                for (var i = 0; i < this.modifiers.length; i++) {\n                    var modName = this.modifiers[i];\n                    var modParams = [];\n                    if (modName.indexOf(\"(\") > 0) {\n                        var regExp = /\\(([^)]+)\\)/;\n\n                        // Todo: ignore any escaped commas.  For now, commas always split\n                        var results = regExp.exec(this.modifiers[i]);\n                        if (!results || results.length < 2) {\n                        } else {\n                            var modParams = results[1].split(\",\");\n                            modName = this.modifiers[i].substring(0, modName.indexOf(\"(\"));\n                        }\n\n                    }\n\n                    var mod = this.grammar.modifiers[modName];\n\n                    // Missing modifier?\n                    if (!mod) {\n                        this.errors.push(\"Missing modifier \" + modName);\n                        this.finishedText += \"((.\" + modName + \"))\";\n                    } else {\n                        this.finishedText = mod(this.finishedText, modParams);\n\n                    }\n\n                }\n\n                // Perform post-actions\n                for (var i = 0; i < this.postactions.length; i++) {\n                    this.postactions[i].activate();\n                }\n                break;\n            case 2:\n\n                // Just a bare action?  Expand it!\n                this.action = new NodeAction(this, this.raw);\n                this.action.activate();\n\n                // No visible text for an action\n                // TODO: some visible text for if there is a failure to perform the action?\n                this.finishedText = \"\";\n                break;\n\n            }\n\n        } else {\n            //console.warn(\"Already expanded \" + this);\n        }\n\n    };\n\n    TraceryNode.prototype.clearEscapeChars = function() {\n\n        this.finishedText = this.finishedText.replace(/\\\\\\\\/g, \"DOUBLEBACKSLASH\").replace(/\\\\/g, \"\").replace(/DOUBLEBACKSLASH/g, \"\\\\\");\n    };\n\n    // An action that occurs when a node is expanded\n    // Types of actions:\n    // 0 Push: [key:rule]\n    // 1 Pop: [key:POP]\n    // 2 function: [functionName(param0,param1)] (TODO!)\n    function NodeAction(node, raw) {\n        /*\n         if (!node)\n         console.warn(\"No node for NodeAction\");\n         if (!raw)\n         console.warn(\"No raw commands for NodeAction\");\n         */\n\n        this.node = node;\n\n        var sections = raw.split(\":\");\n        this.target = sections[0];\n\n        // No colon? A function!\n        if (sections.length === 1) {\n            this.type = 2;\n\n        }\n\n        // Colon? It's either a push or a pop\n        else {\n            this.rule = sections[1];\n            if (this.rule === \"POP\") {\n                this.type = 1;\n            } else {\n                this.type = 0;\n            }\n        }\n    }\n\n\n    NodeAction.prototype.createUndo = function() {\n        if (this.type === 0) {\n            return new NodeAction(this.node, this.target + \":POP\");\n        }\n        // TODO Not sure how to make Undo actions for functions or POPs\n        return null;\n    };\n\n    NodeAction.prototype.activate = function() {\n        var grammar = this.node.grammar;\n        switch(this.type) {\n        case 0:\n            // split into sections (the way to denote an array of rules)\n            this.ruleSections = this.rule.split(\",\");\n            this.finishedRules = [];\n            this.ruleNodes = [];\n            for (var i = 0; i < this.ruleSections.length; i++) {\n                var n = new TraceryNode(grammar, 0, {\n                    type : -1,\n                    raw : this.ruleSections[i]\n                });\n\n                n.expand();\n\n                this.finishedRules.push(n.finishedText);\n            }\n\n            // TODO: escape commas properly\n            grammar.pushRules(this.target, this.finishedRules, this);\n            break;\n        case 1:\n            grammar.popRules(this.target);\n            break;\n        case 2:\n            grammar.flatten(this.target, true);\n            break;\n        }\n\n    };\n\n    NodeAction.prototype.toText = function() {\n        switch(this.type) {\n        case 0:\n            return this.target + \":\" + this.rule;\n        case 1:\n            return this.target + \":POP\";\n        case 2:\n            return \"((some function))\";\n        default:\n            return \"((Unknown Action))\";\n        }\n    };\n\n    // Sets of rules\n    // Can also contain conditional or fallback sets of rulesets)\n    function RuleSet(grammar, raw) {\n        this.raw = raw;\n        this.grammar = grammar;\n        this.falloff = 1;\n\n        if (Array.isArray(raw)) {\n            this.defaultRules = raw;\n        } else if ( typeof raw === 'string' || raw instanceof String) {\n            this.defaultRules = [raw];\n        } else if (raw === 'object') {\n            // TODO: support for conditional and hierarchical rule sets\n        }\n\n    };\n\n    RuleSet.prototype.selectRule = function(errors) {\n        // console.log(\"Get rule\", this.raw);\n        // Is there a conditional?\n        if (this.conditionalRule) {\n            var value = this.grammar.expand(this.conditionalRule, true);\n            // does this value match any of the conditionals?\n            if (this.conditionalValues[value]) {\n                var v = this.conditionalValues[value].selectRule(errors);\n                if (v !== null && v !== undefined)\n                    return v;\n            }\n            // No returned value?\n        }\n\n        // Is there a ranked order?\n        if (this.ranking) {\n            for (var i = 0; i < this.ranking.length; i++) {\n                var v = this.ranking.selectRule();\n                if (v !== null && v !== undefined)\n                    return v;\n            }\n\n            // Still no returned value?\n        }\n\n        if (this.defaultRules !== undefined) {\n            var index = 0;\n            // Select from this basic array of rules\n\n            // Get the distribution from the grammar if there is no other\n            var distribution = this.distribution;\n            if (!distribution)\n                distribution = this.grammar.distribution;\n\n            switch(distribution) {\n            case \"shuffle\":\n\n                // create a shuffle desk\n                if (!this.shuffledDeck || this.shuffledDeck.length === 0) {\n                    // make an array\n                    this.shuffledDeck = fyshuffle(Array.apply(null, {\n                        length : this.defaultRules.length\n                    }).map(Number.call, Number), this.falloff);\n\n                }\n\n                index = this.shuffledDeck.pop();\n\n                break;\n            case \"weighted\":\n                errors.push(\"Weighted distribution not yet implemented\");\n                break;\n            case \"falloff\":\n                errors.push(\"Falloff distribution not yet implemented\");\n                break;\n            default:\n\n                index = Math.floor(Math.pow(rng(), this.falloff) * this.defaultRules.length);\n                break;\n            }\n\n            if (!this.defaultUses)\n                this.defaultUses = [];\n            this.defaultUses[index] = ++this.defaultUses[index] || 1;\n            return this.defaultRules[index];\n        }\n\n        errors.push(\"No default rules defined for \" + this);\n        return null;\n\n    };\n\n    RuleSet.prototype.clearState = function() {\n\n        if (this.defaultUses) {\n            this.defaultUses = [];\n        }\n    };\n\n    function fyshuffle(array, falloff) {\n        var currentIndex = array.length,\n            temporaryValue,\n            randomIndex;\n\n        // While there remain elements to shuffle...\n        while (0 !== currentIndex) {\n\n            // Pick a remaining element...\n            randomIndex = Math.floor(rng() * currentIndex);\n            currentIndex -= 1;\n\n            // And swap it with the current element.\n            temporaryValue = array[currentIndex];\n            array[currentIndex] = array[randomIndex];\n            array[randomIndex] = temporaryValue;\n        }\n\n        return array;\n    }\n\n    var Symbol = function(grammar, key, rawRules) {\n        // Symbols can be made with a single value, and array, or array of objects of (conditions/values)\n        this.key = key;\n        this.grammar = grammar;\n        this.rawRules = rawRules;\n\n        this.baseRules = new RuleSet(this.grammar, rawRules);\n        this.clearState();\n\n    };\n\n    Symbol.prototype.clearState = function() {\n\n        // Clear the stack and clear all ruleset usages\n        this.stack = [this.baseRules];\n\n        this.uses = [];\n        this.baseRules.clearState();\n    };\n\n    Symbol.prototype.pushRules = function(rawRules) {\n        var rules = new RuleSet(this.grammar, rawRules);\n        this.stack.push(rules);\n    };\n\n    Symbol.prototype.popRules = function() {\n        this.stack.pop();\n    };\n\n    Symbol.prototype.selectRule = function(node, errors) {\n        this.uses.push({\n            node : node\n        });\n\n        if (this.stack.length === 0) {\n            errors.push(\"The rule stack for '\" + this.key + \"' is empty, too many pops?\");\n            return \"((\" + this.key + \"))\";\n        }\n\n        return this.stack[this.stack.length - 1].selectRule();\n    };\n\n    Symbol.prototype.getActiveRules = function() {\n        if (this.stack.length === 0) {\n            return null;\n        }\n        return this.stack[this.stack.length - 1].selectRule();\n    };\n\n    Symbol.prototype.rulesToJSON = function() {\n        return JSON.stringify(this.rawRules);\n    };\n\n    var Grammar = function(raw, settings) {\n        this.modifiers = {};\n        this.loadFromRawObj(raw);\n    };\n\n    Grammar.prototype.clearState = function() {\n        var keys = Object.keys(this.symbols);\n        for (var i = 0; i < keys.length; i++) {\n            this.symbols[keys[i]].clearState();\n        }\n    };\n\n    Grammar.prototype.addModifiers = function(mods) {\n\n        // copy over the base modifiers\n        for (var key in mods) {\n            if (mods.hasOwnProperty(key)) {\n                this.modifiers[key] = mods[key];\n            }\n        };\n\n    };\n\n    Grammar.prototype.loadFromRawObj = function(raw) {\n\n        this.raw = raw;\n        this.symbols = {};\n        this.subgrammars = [];\n\n        if (this.raw) {\n            // Add all rules to the grammar\n            for (var key in this.raw) {\n                if (this.raw.hasOwnProperty(key)) {\n                    this.symbols[key] = new Symbol(this, key, this.raw[key]);\n                }\n            }\n        }\n    };\n\n    Grammar.prototype.createRoot = function(rule) {\n        // Create a node and subnodes\n        var root = new TraceryNode(this, 0, {\n            type : -1,\n            raw : rule,\n        });\n\n        return root;\n    };\n\n    Grammar.prototype.expand = function(rule, allowEscapeChars) {\n        var root = this.createRoot(rule);\n        root.expand();\n        if (!allowEscapeChars)\n            root.clearEscapeChars();\n\n        return root;\n    };\n\n    Grammar.prototype.flatten = function(rule, allowEscapeChars) {\n        var root = this.expand(rule, allowEscapeChars);\n\n        return root.finishedText;\n    };\n\n    Grammar.prototype.toJSON = function() {\n        var keys = Object.keys(this.symbols);\n        var symbolJSON = [];\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            symbolJSON.push(' \"' + key + '\" : ' + this.symbols[key].rulesToJSON());\n        }\n        return \"{\\n\" + symbolJSON.join(\",\\n\") + \"\\n}\";\n    };\n\n    // Create or push rules\n    Grammar.prototype.pushRules = function(key, rawRules, sourceAction) {\n\n        if (this.symbols[key] === undefined) {\n            this.symbols[key] = new Symbol(this, key, rawRules);\n            if (sourceAction)\n                this.symbols[key].isDynamic = true;\n        } else {\n            this.symbols[key].pushRules(rawRules);\n        }\n    };\n\n    Grammar.prototype.popRules = function(key) {\n        if (!this.symbols[key])\n            this.errors.push(\"Can't pop: no symbol for key \" + key);\n        this.symbols[key].popRules();\n    };\n\n    Grammar.prototype.selectRule = function(key, node, errors) {\n        if (this.symbols[key]) {\n            var rule = this.symbols[key].selectRule(node, errors);\n\n            return rule;\n        }\n\n        // Failover to alternative subgrammars\n        for (var i = 0; i < this.subgrammars.length; i++) {\n\n            if (this.subgrammars[i].symbols[key])\n                return this.subgrammars[i].symbols[key].selectRule();\n        }\n\n        // No symbol?\n        errors.push(\"No symbol for '\" + key + \"'\");\n        return \"((\" + key + \"))\";\n    };\n\n    // Parses a plaintext rule in the tracery syntax\n    tracery = {\n\n        createGrammar : function(raw) {\n            return new Grammar(raw);\n        },\n\n        // Parse the contents of a tag\n        parseTag : function(tagContents) {\n\n            var parsed = {\n                symbol : undefined,\n                preactions : [],\n                postactions : [],\n                modifiers : []\n            };\n            var sections = tracery.parse(tagContents);\n            var symbolSection = undefined;\n            for (var i = 0; i < sections.length; i++) {\n                if (sections[i].type === 0) {\n                    if (symbolSection === undefined) {\n                        symbolSection = sections[i].raw;\n                    } else {\n                        throw (\"multiple main sections in \" + tagContents);\n                    }\n                } else {\n                    parsed.preactions.push(sections[i]);\n                }\n            }\n\n            if (symbolSection === undefined) {\n                //   throw (\"no main section in \" + tagContents);\n            } else {\n                var components = symbolSection.split(\".\");\n                parsed.symbol = components[0];\n                parsed.modifiers = components.slice(1);\n            }\n            return parsed;\n        },\n\n        parse : function(rule) {\n            var depth = 0;\n            var inTag = false;\n            var sections = [];\n            var escaped = false;\n\n            var errors = [];\n            var start = 0;\n\n            var escapedSubstring = \"\";\n            var lastEscapedChar = undefined;\n\n            if (rule === null) {\n                var sections = [];\n                sections.errors = errors;\n\n                return sections;\n            }\n\n            function createSection(start, end, type) {\n                if (end - start < 1) {\n                    if (type === 1)\n                        errors.push(start + \": empty tag\");\n                    if (type === 2)\n                        errors.push(start + \": empty action\");\n\n                }\n                var rawSubstring;\n                if (lastEscapedChar !== undefined) {\n                    rawSubstring = escapedSubstring + \"\\\\\" + rule.substring(lastEscapedChar + 1, end);\n\n                } else {\n                    rawSubstring = rule.substring(start, end);\n                }\n                sections.push({\n                    type : type,\n                    raw : rawSubstring\n                });\n                lastEscapedChar = undefined;\n                escapedSubstring = \"\";\n            };\n\n            for (var i = 0; i < rule.length; i++) {\n\n                if (!escaped) {\n                    var c = rule.charAt(i);\n\n                    switch(c) {\n\n                    // Enter a deeper bracketed section\n                    case '[':\n                        if (depth === 0 && !inTag) {\n                            if (start < i)\n                                createSection(start, i, 0);\n                            start = i + 1;\n                        }\n                        depth++;\n                        break;\n\n                    case ']':\n                        depth--;\n\n                        // End a bracketed section\n                        if (depth === 0 && !inTag) {\n                            createSection(start, i, 2);\n                            start = i + 1;\n                        }\n                        break;\n\n                    // Hashtag\n                    //   ignore if not at depth 0, that means we are in a bracket\n                    case '#':\n                        if (depth === 0) {\n                            if (inTag) {\n                                createSection(start, i, 1);\n                                start = i + 1;\n                            } else {\n                                if (start < i)\n                                    createSection(start, i, 0);\n                                start = i + 1;\n                            }\n                            inTag = !inTag;\n                        }\n                        break;\n\n                    case '\\\\':\n                        escaped = true;\n                        escapedSubstring = escapedSubstring + rule.substring(start, i);\n                        start = i + 1;\n                        lastEscapedChar = i;\n                        break;\n                    }\n                } else {\n                    escaped = false;\n                }\n            }\n            if (start < rule.length)\n                createSection(start, rule.length, 0);\n\n            if (inTag) {\n                errors.push(\"Unclosed tag\");\n            }\n            if (depth > 0) {\n                errors.push(\"Too many [\");\n            }\n            if (depth < 0) {\n                errors.push(\"Too many ]\");\n            }\n\n            // Strip out empty plaintext sections\n\n            sections = sections.filter(function(section) {\n                if (section.type === 0 && section.raw.length === 0)\n                    return false;\n                return true;\n            });\n            sections.errors = errors;\n            return sections;\n        },\n    };\n\n    function isVowel(c) {\n        var c2 = c.toLowerCase();\n        return (c2 === 'a') || (c2 === 'e') || (c2 === 'i') || (c2 === 'o') || (c2 === 'u');\n    };\n\n    function isAlphaNum(c) {\n        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');\n    };\n    function escapeRegExp(str) {\n        return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n    }\n\n    var baseEngModifiers = {\n\n        replace : function(s, params) {\n            //http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript\n            return s.replace(new RegExp(escapeRegExp(params[0]), 'g'), params[1]);\n        },\n\n        capitalizeAll : function(s) {\n            var s2 = \"\";\n            var capNext = true;\n            for (var i = 0; i < s.length; i++) {\n\n                if (!isAlphaNum(s.charAt(i))) {\n                    capNext = true;\n                    s2 += s.charAt(i);\n                } else {\n                    if (!capNext) {\n                        s2 += s.charAt(i);\n                    } else {\n                        s2 += s.charAt(i).toUpperCase();\n                        capNext = false;\n                    }\n\n                }\n            }\n            return s2;\n        },\n\n        capitalize : function(s) {\n            return s.charAt(0).toUpperCase() + s.substring(1);\n        },\n\n        a : function(s) {\n            if (s.length > 0) {\n                if (s.charAt(0).toLowerCase() === 'u') {\n                    if (s.length > 2) {\n                        if (s.charAt(2).toLowerCase() === 'i')\n                            return \"a \" + s;\n                    }\n                }\n\n                if (isVowel(s.charAt(0))) {\n                    return \"an \" + s;\n                }\n            }\n\n            return \"a \" + s;\n\n        },\n\n        firstS : function(s) {\n            console.log(s);\n            var s2 = s.split(\" \");\n\n            var finished = baseEngModifiers.s(s2[0]) + \" \" + s2.slice(1).join(\" \");\n            console.log(finished);\n            return finished;\n        },\n\n        s : function(s) {\n            switch (s.charAt(s.length -1)) {\n            case 's':\n                return s + \"es\";\n                break;\n            case 'h':\n                return s + \"es\";\n                break;\n            case 'x':\n                return s + \"es\";\n                break;\n            case 'y':\n                if (!isVowel(s.charAt(s.length - 2)))\n                    return s.substring(0, s.length - 1) + \"ies\";\n                else\n                    return s + \"s\";\n                break;\n            default:\n                return s + \"s\";\n            }\n        },\n        ed : function(s) {\n            switch (s.charAt(s.length -1)) {\n            case 's':\n                return s + \"ed\";\n                break;\n            case 'e':\n                return s + \"d\";\n                break;\n            case 'h':\n                return s + \"ed\";\n                break;\n            case 'x':\n                return s + \"ed\";\n                break;\n            case 'y':\n                if (!isVowel(s.charAt(s.length - 2)))\n                    return s.substring(0, s.length - 1) + \"ied\";\n                else\n                    return s + \"d\";\n                break;\n            default:\n                return s + \"ed\";\n            }\n        }\n    };\n\n    tracery.baseEngModifiers = baseEngModifiers; \n    // Externalize\n    tracery.TraceryNode = TraceryNode;\n\n    tracery.Grammar = Grammar;\n    tracery.Symbol = Symbol;\n    tracery.RuleSet = RuleSet;\n\n    tracery.setRng = setRng;\n\n    return tracery;\n}();\n\nmodule.exports = tracery; "],
  "mappings": "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",
  "names": ["setRng", "start"]
}
