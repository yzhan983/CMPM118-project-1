import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/tracery-grammar/tracery.js
var require_tracery = __commonJS({
  "node_modules/tracery-grammar/tracery.js"(exports, module) {
    var tracery = function() {
      var rng = Math.random;
      var setRng = function setRng2(newRng) {
        rng = newRng;
      };
      var TraceryNode = function(parent, childIndex, settings) {
        this.errors = [];
        if (settings.raw === void 0) {
          this.errors.push("Empty input for node");
          settings.raw = "";
        }
        if (parent instanceof tracery.Grammar) {
          this.grammar = parent;
          this.parent = null;
          this.depth = 0;
          this.childIndex = 0;
        } else {
          this.grammar = parent.grammar;
          this.parent = parent;
          this.depth = parent.depth + 1;
          this.childIndex = childIndex;
        }
        this.raw = settings.raw;
        this.type = settings.type;
        this.isExpanded = false;
        if (!this.grammar) {
          this.errors.push("No grammar specified for this node " + this);
        }
      };
      TraceryNode.prototype.toString = function() {
        return "Node('" + this.raw + "' " + this.type + " d:" + this.depth + ")";
      };
      TraceryNode.prototype.expandChildren = function(childRule, preventRecursion) {
        this.children = [];
        this.finishedText = "";
        this.childRule = childRule;
        if (this.childRule !== void 0) {
          var sections = tracery.parse(childRule);
          if (sections.errors.length > 0) {
            this.errors = this.errors.concat(sections.errors);
          }
          for (var i = 0; i < sections.length; i++) {
            this.children[i] = new TraceryNode(this, i, sections[i]);
            if (!preventRecursion)
              this.children[i].expand(preventRecursion);
            this.finishedText += this.children[i].finishedText;
          }
        } else {
          this.errors.push("No child rule provided, can't expand children");
        }
      };
      TraceryNode.prototype.expand = function(preventRecursion) {
        if (!this.isExpanded) {
          this.isExpanded = true;
          this.expansionErrors = [];
          switch (this.type) {
            // Raw rule
            case -1:
              this.expandChildren(this.raw, preventRecursion);
              break;
            // plaintext, do nothing but copy text into finsihed text
            case 0:
              this.finishedText = this.raw;
              break;
            // Tag
            case 1:
              this.preactions = [];
              this.postactions = [];
              var parsed = tracery.parseTag(this.raw);
              this.symbol = parsed.symbol;
              this.modifiers = parsed.modifiers;
              for (var i = 0; i < parsed.preactions.length; i++) {
                this.preactions[i] = new NodeAction(this, parsed.preactions[i].raw);
              }
              for (var i = 0; i < parsed.postactions.length; i++) {
              }
              for (var i = 0; i < this.preactions.length; i++) {
                if (this.preactions[i].type === 0)
                  this.postactions.push(this.preactions[i].createUndo());
              }
              for (var i = 0; i < this.preactions.length; i++) {
                this.preactions[i].activate();
              }
              this.finishedText = this.raw;
              var selectedRule = this.grammar.selectRule(this.symbol, this, this.errors);
              this.expandChildren(selectedRule, preventRecursion);
              for (var i = 0; i < this.modifiers.length; i++) {
                var modName = this.modifiers[i];
                var modParams = [];
                if (modName.indexOf("(") > 0) {
                  var regExp = /\(([^)]+)\)/;
                  var results = regExp.exec(this.modifiers[i]);
                  if (!results || results.length < 2) {
                  } else {
                    var modParams = results[1].split(",");
                    modName = this.modifiers[i].substring(0, modName.indexOf("("));
                  }
                }
                var mod = this.grammar.modifiers[modName];
                if (!mod) {
                  this.errors.push("Missing modifier " + modName);
                  this.finishedText += "((." + modName + "))";
                } else {
                  this.finishedText = mod(this.finishedText, modParams);
                }
              }
              for (var i = 0; i < this.postactions.length; i++) {
                this.postactions[i].activate();
              }
              break;
            case 2:
              this.action = new NodeAction(this, this.raw);
              this.action.activate();
              this.finishedText = "";
              break;
          }
        } else {
        }
      };
      TraceryNode.prototype.clearEscapeChars = function() {
        this.finishedText = this.finishedText.replace(/\\\\/g, "DOUBLEBACKSLASH").replace(/\\/g, "").replace(/DOUBLEBACKSLASH/g, "\\");
      };
      function NodeAction(node, raw) {
        this.node = node;
        var sections = raw.split(":");
        this.target = sections[0];
        if (sections.length === 1) {
          this.type = 2;
        } else {
          this.rule = sections[1];
          if (this.rule === "POP") {
            this.type = 1;
          } else {
            this.type = 0;
          }
        }
      }
      NodeAction.prototype.createUndo = function() {
        if (this.type === 0) {
          return new NodeAction(this.node, this.target + ":POP");
        }
        return null;
      };
      NodeAction.prototype.activate = function() {
        var grammar = this.node.grammar;
        switch (this.type) {
          case 0:
            this.ruleSections = this.rule.split(",");
            this.finishedRules = [];
            this.ruleNodes = [];
            for (var i = 0; i < this.ruleSections.length; i++) {
              var n = new TraceryNode(grammar, 0, {
                type: -1,
                raw: this.ruleSections[i]
              });
              n.expand();
              this.finishedRules.push(n.finishedText);
            }
            grammar.pushRules(this.target, this.finishedRules, this);
            break;
          case 1:
            grammar.popRules(this.target);
            break;
          case 2:
            grammar.flatten(this.target, true);
            break;
        }
      };
      NodeAction.prototype.toText = function() {
        switch (this.type) {
          case 0:
            return this.target + ":" + this.rule;
          case 1:
            return this.target + ":POP";
          case 2:
            return "((some function))";
          default:
            return "((Unknown Action))";
        }
      };
      function RuleSet(grammar, raw) {
        this.raw = raw;
        this.grammar = grammar;
        this.falloff = 1;
        if (Array.isArray(raw)) {
          this.defaultRules = raw;
        } else if (typeof raw === "string" || raw instanceof String) {
          this.defaultRules = [raw];
        } else if (raw === "object") {
        }
      }
      ;
      RuleSet.prototype.selectRule = function(errors) {
        if (this.conditionalRule) {
          var value = this.grammar.expand(this.conditionalRule, true);
          if (this.conditionalValues[value]) {
            var v = this.conditionalValues[value].selectRule(errors);
            if (v !== null && v !== void 0)
              return v;
          }
        }
        if (this.ranking) {
          for (var i = 0; i < this.ranking.length; i++) {
            var v = this.ranking.selectRule();
            if (v !== null && v !== void 0)
              return v;
          }
        }
        if (this.defaultRules !== void 0) {
          var index = 0;
          var distribution = this.distribution;
          if (!distribution)
            distribution = this.grammar.distribution;
          switch (distribution) {
            case "shuffle":
              if (!this.shuffledDeck || this.shuffledDeck.length === 0) {
                this.shuffledDeck = fyshuffle(Array.apply(null, {
                  length: this.defaultRules.length
                }).map(Number.call, Number), this.falloff);
              }
              index = this.shuffledDeck.pop();
              break;
            case "weighted":
              errors.push("Weighted distribution not yet implemented");
              break;
            case "falloff":
              errors.push("Falloff distribution not yet implemented");
              break;
            default:
              index = Math.floor(Math.pow(rng(), this.falloff) * this.defaultRules.length);
              break;
          }
          if (!this.defaultUses)
            this.defaultUses = [];
          this.defaultUses[index] = ++this.defaultUses[index] || 1;
          return this.defaultRules[index];
        }
        errors.push("No default rules defined for " + this);
        return null;
      };
      RuleSet.prototype.clearState = function() {
        if (this.defaultUses) {
          this.defaultUses = [];
        }
      };
      function fyshuffle(array, falloff) {
        var currentIndex = array.length, temporaryValue, randomIndex;
        while (0 !== currentIndex) {
          randomIndex = Math.floor(rng() * currentIndex);
          currentIndex -= 1;
          temporaryValue = array[currentIndex];
          array[currentIndex] = array[randomIndex];
          array[randomIndex] = temporaryValue;
        }
        return array;
      }
      var Symbol = function(grammar, key, rawRules) {
        this.key = key;
        this.grammar = grammar;
        this.rawRules = rawRules;
        this.baseRules = new RuleSet(this.grammar, rawRules);
        this.clearState();
      };
      Symbol.prototype.clearState = function() {
        this.stack = [this.baseRules];
        this.uses = [];
        this.baseRules.clearState();
      };
      Symbol.prototype.pushRules = function(rawRules) {
        var rules = new RuleSet(this.grammar, rawRules);
        this.stack.push(rules);
      };
      Symbol.prototype.popRules = function() {
        this.stack.pop();
      };
      Symbol.prototype.selectRule = function(node, errors) {
        this.uses.push({
          node
        });
        if (this.stack.length === 0) {
          errors.push("The rule stack for '" + this.key + "' is empty, too many pops?");
          return "((" + this.key + "))";
        }
        return this.stack[this.stack.length - 1].selectRule();
      };
      Symbol.prototype.getActiveRules = function() {
        if (this.stack.length === 0) {
          return null;
        }
        return this.stack[this.stack.length - 1].selectRule();
      };
      Symbol.prototype.rulesToJSON = function() {
        return JSON.stringify(this.rawRules);
      };
      var Grammar = function(raw, settings) {
        this.modifiers = {};
        this.loadFromRawObj(raw);
      };
      Grammar.prototype.clearState = function() {
        var keys = Object.keys(this.symbols);
        for (var i = 0; i < keys.length; i++) {
          this.symbols[keys[i]].clearState();
        }
      };
      Grammar.prototype.addModifiers = function(mods) {
        for (var key in mods) {
          if (mods.hasOwnProperty(key)) {
            this.modifiers[key] = mods[key];
          }
        }
        ;
      };
      Grammar.prototype.loadFromRawObj = function(raw) {
        this.raw = raw;
        this.symbols = {};
        this.subgrammars = [];
        if (this.raw) {
          for (var key in this.raw) {
            if (this.raw.hasOwnProperty(key)) {
              this.symbols[key] = new Symbol(this, key, this.raw[key]);
            }
          }
        }
      };
      Grammar.prototype.createRoot = function(rule) {
        var root = new TraceryNode(this, 0, {
          type: -1,
          raw: rule
        });
        return root;
      };
      Grammar.prototype.expand = function(rule, allowEscapeChars) {
        var root = this.createRoot(rule);
        root.expand();
        if (!allowEscapeChars)
          root.clearEscapeChars();
        return root;
      };
      Grammar.prototype.flatten = function(rule, allowEscapeChars) {
        var root = this.expand(rule, allowEscapeChars);
        return root.finishedText;
      };
      Grammar.prototype.toJSON = function() {
        var keys = Object.keys(this.symbols);
        var symbolJSON = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          symbolJSON.push(' "' + key + '" : ' + this.symbols[key].rulesToJSON());
        }
        return "{\n" + symbolJSON.join(",\n") + "\n}";
      };
      Grammar.prototype.pushRules = function(key, rawRules, sourceAction) {
        if (this.symbols[key] === void 0) {
          this.symbols[key] = new Symbol(this, key, rawRules);
          if (sourceAction)
            this.symbols[key].isDynamic = true;
        } else {
          this.symbols[key].pushRules(rawRules);
        }
      };
      Grammar.prototype.popRules = function(key) {
        if (!this.symbols[key])
          this.errors.push("Can't pop: no symbol for key " + key);
        this.symbols[key].popRules();
      };
      Grammar.prototype.selectRule = function(key, node, errors) {
        if (this.symbols[key]) {
          var rule = this.symbols[key].selectRule(node, errors);
          return rule;
        }
        for (var i = 0; i < this.subgrammars.length; i++) {
          if (this.subgrammars[i].symbols[key])
            return this.subgrammars[i].symbols[key].selectRule();
        }
        errors.push("No symbol for '" + key + "'");
        return "((" + key + "))";
      };
      tracery = {
        createGrammar: function(raw) {
          return new Grammar(raw);
        },
        // Parse the contents of a tag
        parseTag: function(tagContents) {
          var parsed = {
            symbol: void 0,
            preactions: [],
            postactions: [],
            modifiers: []
          };
          var sections = tracery.parse(tagContents);
          var symbolSection = void 0;
          for (var i = 0; i < sections.length; i++) {
            if (sections[i].type === 0) {
              if (symbolSection === void 0) {
                symbolSection = sections[i].raw;
              } else {
                throw "multiple main sections in " + tagContents;
              }
            } else {
              parsed.preactions.push(sections[i]);
            }
          }
          if (symbolSection === void 0) {
          } else {
            var components = symbolSection.split(".");
            parsed.symbol = components[0];
            parsed.modifiers = components.slice(1);
          }
          return parsed;
        },
        parse: function(rule) {
          var depth = 0;
          var inTag = false;
          var sections = [];
          var escaped = false;
          var errors = [];
          var start = 0;
          var escapedSubstring = "";
          var lastEscapedChar = void 0;
          if (rule === null) {
            var sections = [];
            sections.errors = errors;
            return sections;
          }
          function createSection(start2, end, type) {
            if (end - start2 < 1) {
              if (type === 1)
                errors.push(start2 + ": empty tag");
              if (type === 2)
                errors.push(start2 + ": empty action");
            }
            var rawSubstring;
            if (lastEscapedChar !== void 0) {
              rawSubstring = escapedSubstring + "\\" + rule.substring(lastEscapedChar + 1, end);
            } else {
              rawSubstring = rule.substring(start2, end);
            }
            sections.push({
              type,
              raw: rawSubstring
            });
            lastEscapedChar = void 0;
            escapedSubstring = "";
          }
          ;
          for (var i = 0; i < rule.length; i++) {
            if (!escaped) {
              var c = rule.charAt(i);
              switch (c) {
                // Enter a deeper bracketed section
                case "[":
                  if (depth === 0 && !inTag) {
                    if (start < i)
                      createSection(start, i, 0);
                    start = i + 1;
                  }
                  depth++;
                  break;
                case "]":
                  depth--;
                  if (depth === 0 && !inTag) {
                    createSection(start, i, 2);
                    start = i + 1;
                  }
                  break;
                // Hashtag
                //   ignore if not at depth 0, that means we are in a bracket
                case "#":
                  if (depth === 0) {
                    if (inTag) {
                      createSection(start, i, 1);
                      start = i + 1;
                    } else {
                      if (start < i)
                        createSection(start, i, 0);
                      start = i + 1;
                    }
                    inTag = !inTag;
                  }
                  break;
                case "\\":
                  escaped = true;
                  escapedSubstring = escapedSubstring + rule.substring(start, i);
                  start = i + 1;
                  lastEscapedChar = i;
                  break;
              }
            } else {
              escaped = false;
            }
          }
          if (start < rule.length)
            createSection(start, rule.length, 0);
          if (inTag) {
            errors.push("Unclosed tag");
          }
          if (depth > 0) {
            errors.push("Too many [");
          }
          if (depth < 0) {
            errors.push("Too many ]");
          }
          sections = sections.filter(function(section) {
            if (section.type === 0 && section.raw.length === 0)
              return false;
            return true;
          });
          sections.errors = errors;
          return sections;
        }
      };
      function isVowel(c) {
        var c2 = c.toLowerCase();
        return c2 === "a" || c2 === "e" || c2 === "i" || c2 === "o" || c2 === "u";
      }
      ;
      function isAlphaNum(c) {
        return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9";
      }
      ;
      function escapeRegExp(str) {
        return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
      }
      var baseEngModifiers = {
        replace: function(s, params) {
          return s.replace(new RegExp(escapeRegExp(params[0]), "g"), params[1]);
        },
        capitalizeAll: function(s) {
          var s2 = "";
          var capNext = true;
          for (var i = 0; i < s.length; i++) {
            if (!isAlphaNum(s.charAt(i))) {
              capNext = true;
              s2 += s.charAt(i);
            } else {
              if (!capNext) {
                s2 += s.charAt(i);
              } else {
                s2 += s.charAt(i).toUpperCase();
                capNext = false;
              }
            }
          }
          return s2;
        },
        capitalize: function(s) {
          return s.charAt(0).toUpperCase() + s.substring(1);
        },
        a: function(s) {
          if (s.length > 0) {
            if (s.charAt(0).toLowerCase() === "u") {
              if (s.length > 2) {
                if (s.charAt(2).toLowerCase() === "i")
                  return "a " + s;
              }
            }
            if (isVowel(s.charAt(0))) {
              return "an " + s;
            }
          }
          return "a " + s;
        },
        firstS: function(s) {
          console.log(s);
          var s2 = s.split(" ");
          var finished = baseEngModifiers.s(s2[0]) + " " + s2.slice(1).join(" ");
          console.log(finished);
          return finished;
        },
        s: function(s) {
          switch (s.charAt(s.length - 1)) {
            case "s":
              return s + "es";
              break;
            case "h":
              return s + "es";
              break;
            case "x":
              return s + "es";
              break;
            case "y":
              if (!isVowel(s.charAt(s.length - 2)))
                return s.substring(0, s.length - 1) + "ies";
              else
                return s + "s";
              break;
            default:
              return s + "s";
          }
        },
        ed: function(s) {
          switch (s.charAt(s.length - 1)) {
            case "s":
              return s + "ed";
              break;
            case "e":
              return s + "d";
              break;
            case "h":
              return s + "ed";
              break;
            case "x":
              return s + "ed";
              break;
            case "y":
              if (!isVowel(s.charAt(s.length - 2)))
                return s.substring(0, s.length - 1) + "ied";
              else
                return s + "d";
              break;
            default:
              return s + "ed";
          }
        }
      };
      tracery.baseEngModifiers = baseEngModifiers;
      tracery.TraceryNode = TraceryNode;
      tracery.Grammar = Grammar;
      tracery.Symbol = Symbol;
      tracery.RuleSet = RuleSet;
      tracery.setRng = setRng;
      return tracery;
    }();
    module.exports = tracery;
  }
});
export default require_tracery();
//# sourceMappingURL=tracery-grammar.js.map
